src_EClass.allInstances->size =  trg_Class.allInstances->size
src_EClass.allInstances->forAll(ec | trg_Class.allInstances->exists(uc | uc.name = ec.name))
src_EClass.allInstances->forAll(ec | trg_Class.allInstances->one(uc | uc.name = ec.name and uc._abstract = ec._abstract))
src_EClass.allInstances->forAll(ec | trg_Class.allInstances->exists(uc | uc.name = ec.name and ec.eAttributes_EAttribute_EClass->forAll(ea | uc.attributes_Attribute_Class->exists(ua | ua.name = ea.name))))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound>1 and not ea._ordered and not ea.unique ) then (ua.type_Attribute_Type.oclIsTypeOf(trg_CollectionType) and ua.type_Attribute_Type.oclAsType(trg_CollectionType).type= #trg_Bag) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound>1 and not ea._ordered and ea.unique ) then (ua.type_Attribute_Type.oclIsTypeOf(trg_CollectionType) and ua.type_Attribute_Type.oclAsType(trg_CollectionType).type= #trg_Set) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound>1 and ea._ordered and not ea.unique ) then (ua.type_Attribute_Type.oclIsTypeOf(trg_CollectionType) and ua.type_Attribute_Type.oclAsType(trg_CollectionType).type= #trg_Sequence) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound>1 and ea._ordered and ea.unique ) then (ua.type_Attribute_Type.oclIsTypeOf(trg_CollectionType) and ua.type_Attribute_Type.oclAsType(trg_CollectionType).type= #trg_Sequence) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound=1 and ea.eAttributeType_EAttribute_EDataType.instanceClassName = 'boolean') then (ua.type_Attribute_Type.oclIsTypeOf(trg_SimpleType) and ua.type_Attribute_Type.oclAsType(trg_SimpleType).type = #trg_Boolean) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound=1 and ea.eAttributeType_EAttribute_EDataType.instanceClassName = 'java.lang.String') then (ua.type_Attribute_Type.oclIsTypeOf(trg_SimpleType) and ua.type_Attribute_Type.oclAsType(trg_SimpleType).type = #trg_String) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound=1 and (ea.eAttributeType_EAttribute_EDataType.instanceClassName = 'double' or ea.eAttributeType_EAttribute_EDataType.instanceClassName = 'float')) then (ua.type_Attribute_Type.oclIsTypeOf(trg_SimpleType) and ua.type_Attribute_Type.oclAsType(trg_SimpleType).type = #trg_Real) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound=1 and ea.eAttributeType_EAttribute_EDataType.instanceClassName = 'int') then (ua.type_Attribute_Type.oclIsTypeOf(trg_SimpleType) and ua.type_Attribute_Type.oclAsType(trg_SimpleType).type = #trg_Integer) else true endif))
src_EAttribute.allInstances->forAll(ea |trg_Attribute.allInstances->exists(ua |ua.name = ea.name and if (ea.upperBound = 1 and ea.eAttributeType_EAttribute_EDataType.oclIsTypeOf(src_EEnum)) then (ua.type_Attribute_Type.oclIsTypeOf(trg_EnumerationType) and ea.eAttributeType_EAttribute_EDataType.oclAsType(src_EEnum).name = ua.type_Attribute_Type.oclAsType(trg_EnumerationType).enum_Enumeration_EnumerationType.name)else true endif))
src_EEnum.allInstances()->forAll(ee | trg_Enumeration.allInstances()->one(ue | ee.name = ue.name))
src_EEnum.allInstances()->forAll(ee | trg_Enumeration.allInstances()->one(ue | ee.name = ue.name and ee.eLiterals_EEnum_EEnumLiteral->forAll(el | ue.literals_Enumeration_Literal->exists(ul | el.name = ul.name))))
trg_Association.allInstances()->forAll (useAssoc | useAssoc.role_Association_Role->size()=2 and src_EReference.allInstances->exists (eRef | (eRef.containment implies useAssoc.kind = #trg_Composition) and (not eRef.containment implies useAssoc.kind = #trg_Association) and useAssoc.role_Association_Role->exists(role | role.className_Class_Role.name = eRef.eReferenceType_EClass_EReference.name and role.lowerBound = eRef.lowerBound and role.upperBound = eRef.upperBound and role._ordered = eRef._ordered)))