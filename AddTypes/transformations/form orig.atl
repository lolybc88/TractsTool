-- @nsURI MM=http://org.topcased.requirement/1.0
-- @path MM1=/tr1/MMtarget/RequisitePro1.ecore

module form;
create OUT : MM1 from IN : MM;

rule root {
	from
		s: MM!RequirementProject 
	to
		t: MM1!Project (
			name <- s.identifier,			
			description <- s.shortDescription,
			--here i need 1 of those twose--
			--**********************************			
			packages <- s.hierarchicalElement,			
			packages <- s.chapter, --, packages <- s.attributeConfiguration,			
			content <- s.attributeConfiguration--, --content <- s.hierarchicalElement
			--**********************************			
			--packages <- s.upstreamModel
		
---allInstances 
--			content <- 	MM!Requirement.allInstances()
---for the second MM
--			,content <- 	s.upstreamModel.documents
		)
}

---this rule have to identify the elements that is are in the second ecore.
---i have retrieve many problems that's why i trete this element in other ATL project "tr3tst""
--rule UpStreamModel {
--	from
--		s : MM!UpstreamModel
--	to
--		t : MM1!Document (
--			name <- s.ident,
--			description <- s.shortDescription--,
--			--type <- s.???????
--			
--			--package <- s.
--			--name <- s.documents.debug()
--		)
--}

--rule UpStreamModel {
--	from
--		s : MM!UpstreamModel 
--	to
--		t : MM1!Package (
--			name <- s.documents.debug()
--		)
--}
--
--rule Package7 {  
--	from
--		s: MM!"ttm::Project" --UpstreamModel()
--	
--	to
--		t: MM1!Package (
--			name <- 'Projet_'+s.anyDocumentCovered--,
--			--packages <- s.documents
--			
----			packages <- 
--			--			name <- s.    s.identifier   --,
----			,description <- s.shortDescription
--			--content <- s.--.requirement,
--			--packages <- s.hierarchicalElement
--		)
--}
--
--rule Package8 {
--	from
--		s: MM!"ttm::Document" --UpstreamModel()
--	
--	to
--		t: MM1!Requirement (
--			name <- 'Document_'+s.filename--,
--			
--			--packages <- s.documents
--			
----			packages <- 
--			--			name <- s.    s.identifier   --,
----			,description <- s.shortDescription
--			--content <- s.--.requirement,
--			--packages <- s.children --hierarchicalElement
--			----NO--il vois les atts mais les att de l'hierarchical et non pas de
--			--- Requirement
--			--text <- s.externalResources.first(),--,
--			--name <- 'Current_'+s.identifier,
--			---text <- s.shortDescription,
--			----the type does not exist
--			--type <- s.
--			---this item is not a valid feature
--			--children <- s.children  --,
--			
--			
--			--attributes <- s.attribute--- -> select(a | a.oclIsTypeOf(MM!TextAttribute))
--		)
--}
---********************************************************

rule Package1 {
	from
		s: MM!HierarchicalElement 
	to
		t: MM1!Package (
			name <- 'HierarchicalElements_'+ s.identifier,
			description <- s.shortDescription,
			content <- s.requirement,
			packages <- s.children
			--,
		)
}

---this rule transformed to 4 rule to identify the source of each one
--rule Package2 {
--	from
--		s: MM!SpecialChapter --()
--	
--	to
--		t: MM1!Package (
--			name <- 'special',
--			--			name <- s.    s.identifier   --,
----			,description <- s.shortDescription
--			content <- s.requirement,
--			packages <- s.hierarchicalElement
--		)
--}
---*******************************************************************
---in package, i need to define description and chek (verifier) name (static name + dynamic name)
abstract rule SpecialChapter{
	from 
		s: MM!SpecialChapter
    to
		t:MM1!Package(
			content <- s.requirement,
			packages <- s.hierarchicalElement
		)
}


rule Package3 extends SpecialChapter{
	from
		s: MM!UntracedChapter 
	to
		t: MM1!Package (
			name <- 'Untraced_'--,
			
--			content <- s.requirement,
--			packages <- s.hierarchicalElement
		)
}

rule Package4 extends SpecialChapter {
	from
		s: MM!ProblemChapter 
	to
		t: MM1!Package (
			name <- 'Problem_'--,
--			content <- s.requirement,
--			packages <- s.hierarchicalElement
		)
}

rule Package5 extends SpecialChapter {
	from
		s: MM!TrashChapter 
	to
		t: MM1!Package (
			--
			name <- 'Trash_'--,
--			content <- s.requirement,
--			packages <- s.hierarchicalElement--,
--			description <- 
		)
}

----ce bout de code produit une erreur que je peut pas la comprendre.
---///
--rule Package7 extends Requirement{
--	from
--		s: MM!DeleteChapter --()
--	to
--		t: MM1!Package (
--			name <- 'special',
--			--			name <- s.    s.identifier   --,
----			,description <- s.shortDescription
--			content <- s.requirement,
--			packages <- s.hierarchicalElement
--		)
--}
---///

----**********************************************************************************


----------------Attribute-----------------------
---au niveau attribute, j'ai besoin de definir name,type et value
abstract rule Attribute{
	from 
		s: MM!Attribute
    to
		t:MM1!Attribute(
			----the type does not exist on the Attribute
			--type <- ???
			----i think, i need to define the name (the data exist in the source MM
			--- but i can't reach this property in the targer MM)
			--??? <- s.name
			-----solution
			--type <- s.name			
		  	type <- s.name.toString()
		)
}


rule TextAttribute extends Attribute{
	from
		s: MM!TextAttribute 	
	to
		t: MM1!Attribute (
			value <- 'Text_'+ s.value, 
			----the type does not exist on the Attribute
			--type <- ???
			----i think, i need to define the name (the data exist in the source MM
			--- but i can't reach this property in the targer MM)
			--??? <- s.name
			-----solution
			--type <- s.name			
		  	type <- s.name.toString()
		)
}

abstract rule ObjectAttribute extends Attribute{
	from 
		s: MM!ObjectAttribute
    to
		t:MM1!Attribute(
--			----the type does not exist on the Attribute
--			--type <- ???
--			----i think, i need to define the name (the data exist in the source MM
--			--- but i can't reach this property in the targer MM)
--			--??? <- s.name
--			-----solution
--			--type <- s.name
--		  	type <- s.name.toString()
		)
}


--rule Package3 extends SpecialChapter{

rule AttributeLink extends ObjectAttribute{
	from
		s: MM!AttributeLink 
	to
		t: MM1!Attribute (
			value <- 'Linkt_'+ s.value--, 
--			----the type does not exist on the Attribute
--			--type <- ???
--			----i think, i need to define the name (the data exist in the source MM
--			--- but i can't reach this property in the targer MM)
--			--??? <- s.name
--			-----solution
--			--type <- s.name
--		  	type <- s.name.toString()	
		)
}

rule AttributeAllocate extends ObjectAttribute{
	from
		s: MM!AttributeAllocate 
	to
		t: MM1!Attribute (
			value <- 'Allocate_'+ s.value--,
--			----the type does not exist on the Attribute
--			--type <- ???
--			----i think, i need to define the name (the data exist in the source MM
--			--- but i can't reach this property in the targer MM)
--			--??? <- s.name
--			-----solution
--			--type <- s.name
--		  	type <- s.name.toString()
		)
}

rule ConfiguratedAttribute {
	from
		s: MM!ConfiguratedAttribute 	
	to
		t: MM1!Attribute (
		value <- if s.listValue->notEmpty() then
			'Configurated_'+ s.defaultValue + '{'+ s.getListValueToString +'}' 
		else 
			OclUndefined--else_statements 
		endif
		,--listValue+s.listValue
		type <- s.type--,
		--value.debug().toString()
		--????<- s.name	
		)
}
helper context MM!ConfiguratedAttribute def : getListValueToString :String =
	self.listValue->iterate(e; res : String = '' |
		if not e.oclIsUndefined()
			then res +' '+ e.value --+','
			else res
		endif
);


---var---in this case, i can't present attribute with many value.
-- TODO : 
--rule DefaultAttribute {
--	from
--		s: MM!DefaultAttributeValue --()
--	
--	to
--		t: MM1!Attribute (
--			value <-'DefaultAttribute_'+ s.value
--		)
--}
----*************************************************************

-------------------------Requirement------------------------------

--rule Requirement {
--	from
--		s : MM!Requirement 
--	to
--		t : MM1!Requirement (
--			----il vois les atts mais les att de l'hierarchical et non pas de
-- Requirement
--			text <- s.externalResources.first()
--			--name <- s.
--			--name <- s.identifier
--			--children <- s.externalResources
--			--type,text
--			--name <- s.ident,
--			--attributes <- s.attribute->including(att)
--		)
--}

---in this case, i have a big problem that i have 1 abstract element and i have 3 target element (requierment, requirementProject, hierarchicalElement)
---the problem is to difine the target model
--abstract rule IdentifiedElement{
--	from 
--		s: MM!IdentifiedElement
--    to
--		t:MM1!??????(
--			children <- s.externalResources,
--			attributes <- s.attribute--- -> select(a | a.oclIsTypeOf(MM!TextAttribute))	
--			,text <- s.shortDescription
--		)
--}


----verifier text, type, name =====>> ok pour text et name, pour le type pas de valeur qui lui correspend a la source
abstract rule Requirement{
	from 
		s: MM!Requirement
    to
		t:MM1!Requirement(
			children <- s.externalResources,
			attributes <- s.attribute--- -> select(a | a.oclIsTypeOf(MM!TextAttribute))	
			,text <- s.shortDescription
			,location <- s.getTheRoot.upstreamModel ---meme que sa marche,je ne trouve pas de resultat convenable puisque le modele cible commence par la balise XMI
---first presentation of the rule in iterative mode			
--			,	location<-if s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().oclIsTypeOf(MM!RequirementProject).debug().toString()  
--							then
--								if not s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().upstreamModel.oclIsUndefined()   
--								--refImmediateComposite().oclIsTypeOf(MM!UpstreamModel).debug().toString()  
--									then
--										s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().upstreamModel.debug().toString()
--										else
--											OclUndefined
--								endif
--							else
--								if s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite()--.oclType()  ----.debug().toString()   
--								then
----								s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().oclIsTypeOf(MM!UpstreamModel).debug().toString() 
--									if s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().oclIsTypeOf(MM!UpstreamModel)--.debug().toString() 
--									then
--										s.refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite().refImmediateComposite()----.debug().toString() 
--										else
--											OclUndefined
--									endif
--								else
--									OclUndefined
--							endif
--						endif
		)
}
				--IdentifiedElementRequirement
helper context MM!IdentifiedElement def : getTheRoot :Set( MM!RequirementProject) =
	if self.refImmediateComposite().oclIsUndefined()  ---i can add a constraint that the element is OclIsTypeof(RequirementProject)
	then 
		self 
	else 
		self.refImmediateComposite().getTheRoot
	endif;

rule UpStreamModel {
	from
		s : MM!UpstreamModel
	to
		t : MM1!Document (
			name <- s.ident,
			description <- s.shortDescription--,
			--type <- s.???????
			
			--package <- s.
			--name <- s.documents.debug()
		)
}

--helper context MM!UpstreamModel def: isFemale(): Boolean =
--	if not self.familyMother.oclIsUndefined() then
--		true
--	else
--		if not self.familyDaughter.oclIsUndefined() then
--			true
--		else
--			false
--		endif
--	endif;

--rule Package3 {

rule Requirement1 extends Requirement{
	from
		s: MM!CurrentRequirement	
	to
		t: MM1!Requirement (
			name <- 'Current_'+s.identifier--,
--			text <- s.shortDescription--,
			----the type does not exist
			--,type <- s.
			
		)
}

rule Requirement2 extends Requirement {
	from
		s: MM!AnonymousRequirement	
	to
		t: MM1!Requirement (
			name <- 'Anonymous_'+s.identifier--,	
--			text <- s.shortDescription--,
			----the type does not exist
			--type <- s.
--			children <- s.externalResources,
--			attributes <- s.attribute
		)
}
---*******************************************************

rule attributeConfiguration {
	from
		s: MM!AttributeConfiguration 
	to
		t: MM1!Requirement (
			----car attribute configuration ne contien pas des elements			
			----becuase the attribute configuration does not contain elements
			----This implies that i can not make a indise so we can't remaque in the target MM.
			----value <-'Configuration'
			attributes <- s.listAttributes -> select(a | a.
					oclIsTypeOf(MM!ConfiguratedAttribute))
--					,
--			attributes <- s.listAttributes -> select(a | a.
--					oclIsTypeOf(MM!DefaultAttributeValue))
		)
}





---to delete----to delete-----to delete----to delete----to delete----to delete-----to delete----to delete
----in the case of the requirement project, i have two solutions. it is to
--- transform the requirement project in a package or into Requirement.
--
--rule RequirementProjecte2 {
--	from
--		s :  MM!RequirementProject--(
----			--s.oclIsTypeOf(MM!Requirement)
----		--)
----
--
----
--	to
--		t : MM1!Package (
--			name <- s.identifier   --,
--			,description <- s.shortDescription
--			,content <- s.requirement
--			,packages <- s.children
--		)
--}

--
--rule RequirementProject3 {
--	from
--		s :  MM!RequirementProject--()
--

--		--()
--	to
--		t : MM1!Requirement (
--

--			----NO--il vois les atts mais les att de l'hierarchical et non pas de
--- Requirement
--			--text <- s.externalResources.first(),--,
--		name <-s.identifier,
--		text <- s.shortDescription,
--		----the type does not exist
--		--type <- s.
--		children <- s.externalResources,
--		attributes <- s.attribute
--		)
--}

----**********************************************************************************
