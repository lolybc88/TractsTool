With respect to the contribution of this paper, two threads of related work are discussed.
First, there are general traceability approaches in software engineering, and second, there are specific approaches for tracking ``guilty'' transformation rules, i.e., those whose behaviour violate the transformation specifications.

IEEE \cite{IEEE90} defines traceability as the degree to which a relationship between two or more artifacts can be established. Most tracing approaches are dedicated to establish traceability links between artifacts that are in a predecessor/successor relationship with respect to their creation time, e.g., between requirements, features, design, architecture, and code. Our approach for automatically finding the alignments between constraints and transformation rules are in the spirit of traceability rules as presented in \cite{RameshD92,PinheiroG96}. A survey dedicated to traceability in the field of MDE is presented in \cite{GalvaoG07}, where the possibilities of using trace links established by model transformations are discussed. However, this survey does not report on tracing approaches between transformation specifications and implementations.

Tracking guilty transformation rules using a dynamic approach, i.e., by executing the model transformation under test, has been subject to investigations. In \cite{Wimmer09}, we used OCL-based queries to backwards debugging of model transformations using an explicit runtime model based on the trace model between the source and target models. Aranega et al. \cite{AranegaMED09} present an approach for situating transformations errors by exploiting also the traces between the source and target models. The dynamic approach is also used by \cite{UjhelyiHV12} to build slices of model transformations. While these approaches are all tracking transformation rules using specific test input models, our aim is to statically build more general traceability models between transformations' specifications and their implementations. In \cite{Jeanneret11}, model footprints of operations are statically computed by the use of metamodel footprints. We pursue the idea of computing metamodel footprints from transformation specifications and implementations for establishing traceability links instead of reasoning on model footprints.
